\input{header.tex}
\begin{document}
\maketitle
\tableofcontents

\newpage

\section{Opis zadania}
Zadaniem projektu jest opracowanie i zaimplementowanie:
\begin{itemize}
\item języka akcji pewnej klasy systemów dynamicznych,
\item języka kwerend, zapewniającego uzyskanie odpowiedzi na określone pytania.
\end{itemize}
Szczegółowy opis klasy systemów dynamicznych oraz języka akcji jest opisany w rozdziale \ref{sc:jezyk_akcji},
natomiast język kwerend oraz zadawane pytania znajdują się w rozdziale \ref{sc:kwerendy}.
W tym dokumencie znajdują się również przykłady.
Pokazują one konkretne przypadki użycia oraz oczekiwane wyniki działania programu.

\section{Język akcji}\label{sc:jezyk_akcji}

Poniższy język został zaprojektowany tak aby spełnić następujące warunki:
\begin{itemize}
	\item Prawo inercji
	\item Linowy model czasu (czas dyskretny)
	\item Skewencyjność działań
	\item Niedeterminizm
	\item Z każdą akcją związane są
		\begin{itemize}
			\item Warunki początkowe
			\item Skutki:
				\begin{description}
					\item[środowiskowe] występują natychmiast po zakończeniu akcji
						\begin{description}
							\item[pewne] występuje zawsze po zakończeniu akcji
							\item[typowe] występują zazwyczaj po zakończeniu akcji
						\end{description}
					\item[dynamiczne] występują po czasie $d \geqslant 0$
						\begin{description}
							\item[pewne] występuje zawsze po zakończeniu akcji
							\item[typowe] występują zazwyczaj po zakończeniu akcji
						\end{description}
				\end{description}
			\item Wykonawca (agent)
			\item Czas trwania $t = 1$
		\end{itemize}	
	\item Pewne stany mogą rozpoczynać wykonywanie pewnych akcji
	\item Agenci mogą nie potrafić wykonać akcji w pewnych stanach. Stany te są określone przez podanie
	warunków lub konkretnych punktów czasowych.	
\end{itemize}
Językiem odpowiadającym powyższym warunkom jest język $\mathcal{AL}$ 
opisujący domeny akcji z czasem liniowym.

\subsection{Opis symboli języka}
\begin{definition}
Język definiujemy jako trójkę
\begin{equation}
\psi = \left( \mathcal{F}, \mathcal{A}, \mathcal{T} \right)
\end{equation}
\begin{itemize}
\item[$\mathcal{F}$] niepusty zbiór inercji (dalej \emph{fluenty})
\item[$\mathcal{A}$] niepusty zbiór akcji (dalej \emph{akcje}), 
$\mathcal{A} = \left\lbrace (\Lambda, \tau) : \Lambda \in \textbf{Agents}, \tau \in \textbf{Tasks} \right\rbrace$
\item[$\mathcal{T}$] niepusty zbiór punktów czasu, $\mathcal{T} = \mathbb{N}$
\end{itemize}
\end{definition}

\subsection{Syntaktyka języka}
\todo[inline]{nie jestem pewien czy tak to powinno wyglądać}
\begin{description}[style=nextline]
	\item[$\texttt{initially } \alpha$]	
	stan początkowy fluentów w formule $\alpha$
	\item[$a_i \texttt{ causes } \alpha \texttt{ if } \pi$]
	akcja $a_i$\footnote{akcja $a_i$ złożona jest z agenta ($\Lambda$) i zadania ($\tau$), które wykonuje}
	powoduje przejście w stan $\alpha$ jeśli zachodzi warunek $\pi$
	\item[$\texttt{typically } a_i \texttt{ causes } \alpha \texttt{ if } \pi$]
	zazwyczaj akcja $a_i$ powoduje przejście w stan $\alpha$ jeśli zachodzi warunek $\pi$
	\item[$a_i \texttt{ invokes } a_j \texttt{ after } d \texttt{ if } \pi$] 
	akcja $a_i$ powoduje wykonanie akcji $a_j$ po $d$ chwilach od zakończenia akcji $a_i$,
	jeśli zachodzi warunek $\pi$
	\item[$\texttt{typically } a_i \texttt{ invokes } a_j \texttt{ after } d \texttt{ if } \pi$] 
	zazwyczaj akcja $a_i$ powoduje wykonanie akcji $a_j$ po $d$ chwilach od zakończenia akcji $a_i$,
	jeśli zachodzi warunek $\pi$
	\item[$a_i \texttt{ releases } f \texttt{ after } d \texttt{ if } \pi$] 
	akcja $a_i$ powoduje uwolnienie fluentu $f$ po $d$ chwilach od zakończenia akcji $a_i$,
	jeśli zachodzi warunek $\pi$	
	\item[$\texttt{typically } a_i \texttt{ releases } f \texttt{ after } d \texttt{ if } \pi$] 
	zazwyczaj akcja $a_i$ powoduje uwolnienie fluentu $f$ po $d$ chwilach od zakończenia akcji $a_i$,
	jeśli zachodzi warunek $\pi$	
	\item[$\pi \texttt{ triggers } a_i$] 
	jeśli zachodzi warunek $\pi$	to wykonywana jest akcja $a_i$
	\item[$\texttt{typically }\pi \texttt{ triggers } a_i$] 
	zazwyczaj jeśli zachodzi warunek $\pi$ to wykonywana jest akcja $a_i$
	\item[$\texttt{impossible } a_i \texttt{ at } t \texttt{ if } \pi$] 
	akcja $a_i$ jest niemożliwa  w chwili $t$, jeśli zachodzi warunek $\pi$	
	\item[$\texttt{always } \pi$] 
	każdy stan spełnia warunek $\pi$
\end{description}

\begin{example}\label{przyk:syntaktyka_jezyka_akcji}
	Rozważmy przykład studenta Janka. Janek mieszka w akademiku.
	Przed wyjściem zazwyczaj bierze ze sobą kartę do wstępu do akademika i zamyka pokój.
	W chwili 10 cieć zamyka akademik i można wejść tylko z kartą.
	\begin{align*}
	&\texttt{initially } \neg roomClosed, \neg hostelClosed, inHostel, \neg hasCard \\
	&closeDoor \texttt{ causes } hostelClosed \\
	&\texttt{typically } \neg hasCard \texttt{ triggers } TakeCard \\
	&\texttt{typically } Leave \texttt{ invokes } LockTheDoor \\
	&\textsc{Janek } TakeCard \texttt{ causes } hasCard \\
	&\textsc{Janek } Leave \texttt{ causes } \neg inHostel \\
	&Comeback \texttt{ causes } inHostel \texttt{ after } 10 \texttt{ if } hasCard \\
	&\texttt{typically } \textsc{DoorKepper } closeDoor \texttt{ occures at } 10
	\end{align*}
\end{example}


\subsection{Scenariusze działań}
\begin{definition}
Scenariusze działań definiujemy jako zbiór obserwacji i akcji:
\begin{equation}
	Sc = (OBS, ACS)\\
\end{equation}
\begin{description}
	\item[$OBS = \lbrace(\gamma_1, t_1), \dots, (\gamma_m, t_m)\rbrace$]
	obserwacja, każda obserwacja jest stanem spełniającym warunek $\gamma$ w pewnej chwili $t$
	\item[$ACS = \lbrace(a_1, t_1), \dots, (a_n, t_n) \rbrace$]
	gdzie $a_i$ -- akcje, $t_i$ -- punkt w czasie rozpoczęcia akcji
\end{description}
\end{definition}

\subsection{Semantyka}
\begin{definition}
Semantyczną strukturą języka $\mathcal{AL}$ nazywamy system $ S=(H,O,E,T_{\infty }) $ taki, że:
	\begin{itemize}
		\item $ H: Forms(F) $ $\times$ $ \mathbb{N}$ $\longrightarrow$ $\{0,1\}$ jest funkcją historii, pozwala ona stwierdzić, jaki stan ma pewny fluent lub czy dana formuła jest spełniona, dla określonej chwili czasu $t$.
		\item $ O: Ac$ $\times$ $ \mathbb{N}$ $\longrightarrow$ $2^{F}$ jest funkcją okluzji. Dla pewnej ustalonej akcji $A \in Ac$, chwili czasu $t\in\mathbb{N}$, funkcja $O(A,t) $ zwraca zbiór fluentów, na który akcja $A$ ma wpływ, jeśli będzie ona trwała w chwili $t$. 
Wartość funkcji okluzji będziemy nazywać regionem okluzji. 
		\item $E\subseteq Ac \times \mathbb{N} \times \mathbb{N}$ jest relacją wykonań akcji. Dwójka $(A,t)$ należy do relacji $E$ jeśli akcja $A$ trwająca jedną jednostkę czasu jest rozpoczęta w czasie t. W naszym modelu zakładamy warunek sekwencyjności działań. Oznacza on, że w danym czasie możemy wykonać tylko jedną akcje, tak więc jeśli $(t_{1},t_{1} + 1) \subseteq (t_{2},t_{2}+1)$, lub $(t_{2},t_{2}+1 ) \subseteq (t_{1},t_{1}+1) $ oraz $(A,t_{1})\in E$ i $(B,t_{2})\in E$, to $A=B$, $t_{1}=t_{2}$. Natomiast jeżeli $(t_{1},t_{1}+1 \nsubseteq (t_{2},t_{2}+1 )$, $(t_{2},t_{2}+1 ) \nsubseteq (t_{1},t_{1}+1) $ oraz $(A,t_{1})\in E$ i $(B,t_{2})\in E$, to $t_{1}+1<t_{2}$ lub $t_{2}+1<t_{1}$.
		\item $T_{\infty } \in \mathbb{N} $ jest czasem zakończenia scenariusza, może to być dowolnie duża ustalona liczba naturalna. 
		Wielkość ta informuje o tym, do kiedy powinny być zakończone wszystkie akcje w danym scenariuszu. Stąd scenariusze nieskończone nie będą rozpatrywane. 
	\end{itemize}
\end{definition}

Niech: $A,B$ będą akcjami, $ f $ - fluentem, $\alpha, \pi$ - formułami, a $fl(\alpha)$ zbiorem fluentów występujących w $\alpha$. Wtedy dla zdań języka $\mathcal{AL}$  muszą być spełnione następujące warunki: 
\todo[inline]{dodać typically}
   \begin{itemize} 
   		\item Dla każdego wyrażenia $ ( A\;causes\;\alpha\;if\;\pi)\in D $ i dla każdego momentu w czasie $t \in \mathbb{N}$, jeżeli $H(\pi,t)=1$ oraz $(A,t) \in E$, wtedy $H(\alpha,t + 1)=1$ mamy $fl(\alpha)\subseteq O(A,t + 1)$.
 		\item Dla każdego wyrażenia $( A\;invokes\;B\;after\;d\;\;if\;\pi)\in D$ i dla każdego momentu czasu $t \in \mathbb{N}$, jeżeli $H(\pi,t)=1$, $(A,t)\in E $ oraz $t+1+d\leq T_{\infty}$, wtedy $(B,t+1+d) \in E $.
   		\item Dla każdego wyrażenia $( A \;releases\;f\;if\;\pi)\in D $ i dla każdego momentu czasu $t \in \mathbb{N}$, jeżeli $H(\pi,t)=1$ oraz $(A,t)\in E$, wtedy mamy $f\in O(A,t+1)$.
   		\item Dla każdego wyrażenia $(\pi\;triggers\; A)\in D$ i dla każdego momentu czasu $t \in \mathbb{N}$, jeżeli $H(\pi,t)=1$ oraz $t+1\leq T_{\infty}$, wtedy $(A,t)\in E$.
		\item Dla każdego wyrażenia $(impossible \; A \; if\;  \pi )$ i dla każdego momentu czasu $t \in \mathbb{N}$, jeżeli $H(\pi,t)=1$, wtedy $(A,t) \notin E $.
		\item Dla każdego wyrażenia $(always \; \pi )$ i dla każdego momentu czasu $t \in \mathbb{N}$, $H(\pi,t)=1$.
   \end{itemize}
   \begin{definition}
   Niech $S = (H,O,E,T_{\infty})$ będzie strukturą języka $\mathcal{AL}$ , $ Sc=(OBS,ACS) $ będzie scenariuszem, oraz $ D $ dziedziną. Powiemy, że $ S $ jest strukturą dla $Sc$ zgodną z opisem domeny $D$, jeśli:
   		\begin{itemize} 
     		\item Dla każdej obserwacji $(\alpha,t )\in OBS$ mamy $H(\alpha,t )=1$
     		\item $ACS \subseteq E$ 
     		\item Dla każdej akcji $ {A \in Ac}$ oraz dla każdego czasu rozpoczęcia akcji $t \in \mathbb{N}$, jeżeli $(A,t) \in E $, to $t+1 \leq T_{\infty}$. 
    		\end{itemize} 
   \end{definition}
   \begin{definition}
	   Niech $O_{1}$,$O_{2}$: $X \longrightarrow 2^{Y}$. Mówimy, że $O_{1} \prec O_{2}$ jeżeli $\forall x\in X$ $O_{1}(x)\subseteq O_{2}(x)$ oraz $O_{1}\neq O_{2}$.
   \end{definition}
   
   \begin{definition}
   Niech $S=(H,O,E,T_{\infty})$ będzie strukturą dla scenariusza $Sc=(OBS,ACS)$ zgodną z opisem dziedziny $D$. Mówimy, że $S$ jest $O$-minimalną strukturą, jeżeli nie istnieje struktura \\$S'=(H',O',E',T_{\infty}')$ dla tego samego scenariusza i domeny taka, że $O'\prec O$.  
   \end{definition}
   \begin{definition}
   Niech $S=(H,O,E,T_{\infty})$ będzie strukturą dla scenariusza $Sc=(OBS,ACS)$ zgodną z opisem domeny $D$. $S$ będziemy nazywać modelem $Sc$ zgodnym z opisem $D$ jeżeli:
   \begin{itemize}
		\item $S$ jest $O$-minimalny
		\item Dla każdego momentu w czasie $t \in \mathbb{N}$,  \{$f\in F$: $H(f,t)\neq H(f,t+1) $\} $\subseteq O(A,t+1)$ dla pewnej akcji $A$.
		\item Nie istnieje żadna struktura $S'=(H',O',E')$ dla $Sc$ zgodna z opisem $D$, która spełnia poprzednie warunki oraz taka, że $E'\subset E$. 
   \end{itemize}
\end{definition}

\begin{remark}
Nie dla każdego scenariusza można ułożyć model. Mówimy, że scenariusz $Sc$ jest \textit{zgodny} jeśli istnieje do niego model zgodny z dziedziną $D$.
\end{remark}

\section{Język zapytań}\label{sc:kwerendy}
Zdefiniowany język akcji może być odpytywany przez poniższy język zapytań,
który zwraca odpowiedzi \texttt{TRUE/FALSE} na następujące pytania
\begin{description}[style=nextline]
	\item[Czy w chwili $t$ realizacji scenariusza $Sc$ warunek $\gamma$ zachodzi zawsze/kiedykolwiek/na ogół?]
	$\texttt{always/ever/generally } \gamma \texttt{ at } t \texttt{ when } Sc$
	\item[Czy w chwili $t$ realizacji scenariusza $Sc$ akcja $a$ wykonywana jest zawsze/kiedykolwiek?]
	$\texttt{always/ever/generally performed } a \texttt{ at } t \texttt{ when } Sc$
	\item[Czy realizacji scenariusza $Sc$ zaangażowana jest grupa agentów $Ag$ zawsze/kiedykolwiek?]
	$\texttt{always/ever involved } Ag \texttt{ when } Sc$	
\end{description}

\subsection{Przykłady}
Rozważmy system opisany w przykładzie \ref{przyk:syntaktyka_jezyka_akcji}.
\begin{example}[Czy Cieć jest zawsze zaangażowany w realizację scenariusza]
	$$
	\texttt{always involved } \textsc{DoorKepper} \texttt{ when } Sc
	$$
	$\texttt{FALSE}$ -- Cieć zazwyczaj zamyka akademik ale nie zawsze.
\end{example}
\begin{example}[Czy w chwili 11 realizacji scenariusza $Sc$ Janek zawsze jest w akademiku]
	$$
	\texttt{always } inHostel \texttt{ at } 11 \texttt{ when } Sc
	$$
	$\texttt{FALSE}$ -- Janek zazwyczaj ma klucz który umożliwia wejście do akademika ale nie zawsze.
\end{example}


\subsection{Semantyka}
Niech $Sc$ będzie scenariuszem, a $D$ opisem domeny języka. Powiemy, że kwerenda $Q$ jest konsekwencją $Sc$ zgodnie z $D$ (ozn. $Sc,\ D\ |\approx\ Q $)

\begin{itemize}
	\item zapytanie kwerendą $Q$ postaci $executable\ Sc$\\ zwróci wynik $TRUE$ jeśli dla każdej ścieżki wykonania istnieje model $S=(H,O,E,T_{\infty})$ zgodny z $D$ dla scenariusza $Sc$.

	\item zapytanie kwerendą $Q$ postaci $\gamma\ at\ t\ when\ Sc$\\ zwróci wynik $TRUE$ jeśli dla każdego modelu $S=(H,O,E,T_{\infty})$ scenariusza $Sc$ zgodnego z $D$ zajdzie $H(\gamma,t)=1$
	\item zapytanie kwerendą $Q$ postaci $\gamma\ when\ Sc$\\ zwróci wynik $TRUE$ jeśli dla każdego modelu $S=(H,O,E,T_{\infty})$ scenariusza $Sc$ zgodnego z $D$ zajdzie $\exists_{t \in N}\ H(\gamma,t)=1$.

	\item zapytanie kwerendą $Q$ postaci $performing\ A\ at\ t\ when\ Sc$\\ zwróci wynik $TRUE$ jeśli dla każdego modelu $S=(H,O,E,T_{\infty})$ scenariusza $Sc$ zgodnego z $D$ zajdzie $\exists_{d \in N}\ (A,t,d) \in E$.
	\item zapytanie kwerendą $Q$ postaci $performing\ A\ when\ Sc$\\ zwróci wynik $TRUE$ jeśli dla każdego modelu $S=(H,O,E,T_{\infty})$ scenariusza $Sc$ zgodnego z $D$ zajdzie $\exists_{t \in N}\ \exists_{d \in N}\ (A,t,d) \in E$.
	\item zapytanie kwerendą $Q$ postaci $performing\ at\ t\ when\ Sc$\\ zwróci wynik $TRUE$ jeśli dla każdego modelu $S=(H,O,E,T_{\infty})$ scenariusza $Sc$ zgodnego z $D$ zajdzie $\exists_{A \in Ac}\ \exists_{d \in N}\ (A,t,d) \in E$.

	\item zapytanie kwerendą $Q$ postaci $accesible\ \gamma\ when\ Sc$\\ zwróci wynik $TRUE$ jeśli dla każdego modelu $S=(H,O,E,T_{\infty})$ scenariusza $Sc$ zgodnego z $D$ zajdzie $\exists(A_{0},...,A_{n} \in ACS, n \geqslant 0)\  \exists_{t \in N}\ H(\gamma,t)=1$.
\end{itemize}

\begin{remark}
   Jeśli warunek nie zajdzie program zwróci wartość $FALSE$.
\end{remark}
\section{Przykłady}
\todo{Dodać kilka przykładów z scenariuszem (+ ilustracja), kwerendą i wyjaśnieniem dlaczego tak}
\begin{example}
	\begin{align*}
		&\texttt{initially} \neg hasMoney, \neg hasBread \\
	 	&\neg hasMoney &\texttt{triggers}, UseATM \\
		&UseATM &\texttt{typically triggers} BuyBread \\
		&BuyBread &\texttt{causes} hasBread, \neg hasMoney \\
		&hasBread &\texttt{typically invokes} EatBread \\
 		&EatBread &\texttt{causes} \neg hasBread \\
	\end{align*}
\end{example}

\end{document}
