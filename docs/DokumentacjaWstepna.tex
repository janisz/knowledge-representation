\input{header.tex}
\begin{document}
\maketitle
\tableofcontents

\newpage

\section{Opis zadania}
Zadaniem projektu jest opracowanie i zaimplementowanie:
\begin{itemize}
\item języka akcji pewnej klasy systemów dynamicznych,
\item języka kwerend, zapewniającego uzyskanie odpowiedzi na określone pytania.
\end{itemize}
Szczegółowy opis klasy systemów dynamicznych oraz języka akcji jest opisany w rozdziale \ref{sc:jezyk_akcji},
natomiast język kwerend oraz zadawane pytania znajdują się w rozdziale \ref{sc:kwerendy}.
W tym dokumencie znajdują się również przykłady.
Pokazują one konkretne przypadki użycia oraz oczekiwane wyniki działania programu.

\section{Język akcji}\label{sc:jezyk_akcji}

Poniższy język został zaprojektowany tak aby spełnić następujące warunki:
\begin{itemize}
	\item Prawo inercji
	\item Linowy model czasu (czas dyskretny)
	\item Skewencyjność działań
	\item Niedeterminizm
	\item Z każdą akcją związane są
		\begin{itemize}
			\item Warunki początkowe
			\item Skutki:
				\begin{description}
					\item[środowiskowe] występują natychmiast po zakończeniu akcji
						\begin{description}
							\item[pewne] występuje zawsze po zakończeniu akcji
							\item[typowe] występują zazwyczaj po zakończeniu akcji
						\end{description}
					\item[dynamiczne] występują po czasie $d \geqslant 0$
						\begin{description}
							\item[pewne] występuje zawsze po zakończeniu akcji
							\item[typowe] występują zazwyczaj po zakończeniu akcji
						\end{description}
				\end{description}
			\item Wykonawca (agent)
			\item Czas trwania $t = 1$
		\end{itemize}	
	\item Pewne stany mogą rozpoczynać wykonywanie pewnych akcji
	\item Agenci mogą nie potrafić wykonać akcji w pewnych stanach. Stany te są określone przez podanie
	warunków lub konkretnych punktów czasowych.	
\end{itemize}
Językiem odpowiadającym powyższym warunkom jest język $\mathcal{AL}$ 
opisujący domeny akcji z czasem liniowym.

\subsection{Opis symboli języka}
\begin{definition}
Język definiujemy jako trójkę
\begin{equation}
\psi = \left( \mathcal{F}, \mathcal{A}, \mathcal{T} \right)
\end{equation}
\begin{itemize}
\item[$\mathcal{F}$] niepusty zbiór inercji (dalej \emph{fluenty})
\item[$\mathcal{A}$] niepusty zbiór akcji (dalej \emph{akcje}), 
$\mathcal{A} = \left\lbrace (\Lambda, \tau) : \Lambda \in \textbf{Agents}, \tau \in \textbf{Tasks} \right\rbrace$
\item[$\mathcal{T}$] niepusty zbiór punktów czasu, $\mathcal{T} = \mathbb{N}$
\end{itemize}
\end{definition}

\subsection{Syntaktyka języka}
\todo[inline]{nie jestem pewien czy tak to powinno wyglądać}
\begin{description}[style=nextline]
	\item[$\texttt{initially } \alpha$]	
	stan początkowy fluentów w formule $\alpha$
	\item[$a_i \texttt{ causes } \alpha \texttt{ if } \pi$]
	akcja $a_i$\footnote{akcja $a_i$ złożona jest z agenta ($\Lambda$) i zadania ($\tau$), które wykonuje}
	powoduje przejście w stan $\alpha$ jeśli zachodzi warunek $\pi$
	\item[$\texttt{typically } a_i \texttt{ causes } \alpha \texttt{ if } \pi$]
	zazwyczaj akcja $a_i$ powoduje przejście w stan $\alpha$ jeśli zachodzi warunek $\pi$
	\item[$a_i \texttt{ invokes } a_j \texttt{ after } d \texttt{ if } \pi$] 
	akcja $a_i$ powoduje wykonanie akcji $a_j$ po $d$ chwilach od zakończenia akcji $a_i$,
	jeśli zachodzi warunek $\pi$
	\item[$\texttt{typically } a_i \texttt{ invokes } a_j \texttt{ after } d \texttt{ if } \pi$] 
	zazwyczaj akcja $a_i$ powoduje wykonanie akcji $a_j$ po $d$ chwilach od zakończenia akcji $a_i$,
	jeśli zachodzi warunek $\pi$
	\item[$a_i \texttt{ releases } f \texttt{ after } d \texttt{ if } \pi$] 
	akcja $a_i$ powoduje uwolnienie fluentu $f$ po $d$ chwilach od zakończenia akcji $a_i$,
	jeśli zachodzi warunek $\pi$	
	\item[$\texttt{typically } a_i \texttt{ releases } f \texttt{ after } d \texttt{ if } \pi$] 
	zazwyczaj akcja $a_i$ powoduje uwolnienie fluentu $f$ po $d$ chwilach od zakończenia akcji $a_i$,
	jeśli zachodzi warunek $\pi$	
	\item[$\pi \texttt{ triggers } a_i$] 
	jeśli zachodzi warunek $\pi$	to wykonywana jest akcja $a_i$
	\item[$\texttt{typically }\pi \texttt{ triggers } a_i$] 
	zazwyczaj jeśli zachodzi warunek $\pi$ to wykonywana jest akcja $a_i$
	\item[$\texttt{impossible } a_i \texttt{ at } t \texttt{ if } \pi$] 
	akcja $a_i$ jest niemożliwa  w chwili $t$, jeśli zachodzi warunek $\pi$	
	\item[$\texttt{always } \pi$] 
	każdy stan spełnia warunek $\pi$
\end{description}

\begin{example}\label{przyk:syntaktyka_jezyka_akcji}
	Rozważmy przykład studenta Janka. Janek mieszka w akademiku.
	Przed wyjściem zazwyczaj bierze ze sobą kartę do wstępu do akademika i zamyka pokój.
	W chwili 10 cieć zamyka akademik i można wejść tylko z kartą.
	\begin{align*}
	&\texttt{initially } \neg roomClosed, \neg hostelClosed, inHostel, \neg hasCard \\
	&closeDoor \texttt{ causes } hostelClosed \\
	&\texttt{typically } \neg hasCard \texttt{ triggers } TakeCard \\
	&\texttt{typically } Leave \texttt{ invokes } LockTheDoor \\
	&\textsc{Janek } TakeCard \texttt{ causes } hasCard \\
	&\textsc{Janek } Leave \texttt{ causes } \neg inHostel \\
	&Comeback \texttt{ causes } inHostel \texttt{ after } 10 \texttt{ if } hasCard \\
	&\texttt{typically } \textsc{DoorKepper } closeDoor \texttt{ occures at } 10
	\end{align*}
\end{example}


\subsection{Scenariusze działań}
\begin{definition}
Scenariusze działań definiujemy jako zbiór obserwacji i akcji:
\begin{equation}
	Sc = (OBS, ACS)\\
\end{equation}
\begin{description}
	\item[$OBS = \lbrace(\gamma_1, t_1), \dots, (\gamma_m, t_m)\rbrace$]
	obserwacja, każda obserwacja jest stanem spełniającym warunek $\gamma$ w pewnej chwili $t$
	\item[$ACS = \lbrace(a_1, t_1), \dots, (a_n, t_n) \rbrace$]
	gdzie $a_i$ -- akcje, $t_i$ -- punkt w czasie rozpoczęcia akcji
\end{description}
\end{definition}

\subsection{Semantyka}
\begin{definition}
Semantyczną strukturą języka $\mathcal{AL}$ nazywamy system $ S=(H,O,E,N,T_{\infty }) $ taki, że:
	\begin{itemize}
		\item $ H: Forms(\mathcal{F}) $ $\times$ $ \mathcal{T}$ $\longrightarrow$ $\{0,1\}$ jest funkcją historii, pozwala ona stwierdzić, jaki stan ma pewny fluent lub czy dana formuła jest spełniona, dla określonej chwili czasu $t$.
		\item $ O: \mathcal{A}$ $\times$ $ \mathcal{T}$ $\longrightarrow$ $2^{\mathcal{F}}$ jest funkcją okluzji. Dla pewnej ustalonej akcji $a_i \in \mathcal{A}$, chwili czasu $t\in\mathbb{N}$, funkcja $O(a_i,t) $ zwraca zbiór fluentów, na który akcja $a_i$ ma wpływ, jeśli będzie ona trwała w chwili $t$. 
Wartość funkcji okluzji będziemy nazywać regionem okluzji. 
		\item $E\subseteq \mathcal{A} \times \mathcal{T}$ jest relacją wykonań akcji. Dwójka $(a_i,t)$ należy do relacji $E$ jeśli akcja $a_i$ trwająca jednostkę czasu jest rozpoczęta w czasie t. W naszym modelu zakładamy warunek sekwencyjności działań. Oznacza on, że w danym czasie możemy wykonać tylko jedną akcje, tak więc jeśli $(a_i, t_1) \in E \land (a_j, t_2) \in E \implies t_1 \neq t_2 \lor a_i = a_j$.
		\item $N\subseteq \mathcal{A} \times \mathcal{T}$ jest relacją typowości. 
				\todo{nie mam pojęcia czy ten punkt dobrze prztłumaczyłem, ktoś ma lepsze pomysły?}
		Dwójka $(a_i,t)$ należy do relacji $N$, jeśli w chwili $t$ dany stan jest typowy dla akcji $a_i$. 
		\item $T_{\infty } \in \mathcal{T} $ jest czasem zakończenia scenariusza, może to być dowolnie duża ustalona liczba naturalna. 
		Wielkość ta informuje o tym, do kiedy powinny być zakończone wszystkie akcje w danym scenariuszu. Stąd scenariusze nieskończone nie będą rozpatrywane. 
	\end{itemize}
\end{definition}

Niech: $a_i,a_j$ będą akcjami, $ f $ - fluentem, $\alpha, \pi$ - formułami, a $fl(\alpha)$ zbiorem fluentów występujących w $\alpha$. Wtedy dla zdań języka $\mathcal{AL}$  muszą być spełnione następujące warunki: 
   \begin{itemize} 
   		\item Dla każdego wyrażenia $ ( a_i\;causes\;\alpha\;if\;\pi)\in D $ i dla każdego momentu w czasie $t \in \mathcal{T}$, jeżeli $H(\pi,t)=1$ oraz $(a_i,t) \in E$, wtedy $H(\alpha,t + 1)=1$ mamy $fl(\alpha)\subseteq O(a_i,t + 1)$.
		\item Dla każdego wyrażenia $ ( typically\; a_i\;causes\;\alpha\;if\;\pi)\in D $ i dla każdego momentu w czasie $t \in \mathcal{T}$, jeżeli $(a_i,t) \in N$, to $(a_i,t) \in E$.
 		\item Dla każdego wyrażenia $( a_i\;invokes\;a_j\;after\;d\;\;if\;\pi)\in D$ i dla każdego momentu czasu $t \in \mathcal{T}$, jeżeli $H(\pi,t)=1$, $(a_i,t)\in E $ oraz $t+1+d\leq T_{\infty}$, wtedy $(a_j,t+1+d) \in E $.
	 	\item Dla każdego wyrażenia $( typically\; a_i\;invokes\;a_j\;after\;d\;\;if\;\pi)\in D$ i dla każdego momentu czasu $t \in \mathcal{T}$, jeżeli $H(\pi,t)=1$, $(a_i,t)\in E$, $(a_j, t + d)\in N $ oraz $t+1+d\leq T_{\infty}$, wtedy $(a_j,t+1+d) \in E $.
   		\item Dla każdego wyrażenia $( a_i\;releases\;f\;if\;\pi)\in D $ i dla każdego momentu czasu $t \in \mathcal{T}$, jeżeli $H(\pi,t)=1$ oraz $(a_i,t)\in E$, wtedy mamy $f\in O(a_i,t+1)$.
 		\item Dla każdego wyrażenia $( typically\; a_i \;releases\;f\;if\;\pi)\in D $ i dla każdego momentu czasu $t \in \mathcal{T}$, jeżeli $H(\pi,t)=1$ oraz $(a_i,t)\in E$ i $(a_i,t)\in N$, wtedy mamy $f\in O(a_i,t+1)$.
   		\item Dla każdego wyrażenia $(\pi\;triggers\; a_i)\in D$ i dla każdego momentu czasu $t \in \mathcal{T}$, jeżeli $H(\pi,t)=1$ oraz $t+1\leq T_{\infty}$, wtedy $(a_i,t)\in E$.
		\item Dla każdego wyrażenia $(typically\; \pi\;triggers\; a_i)\in D$ i dla każdego momentu czasu $t \in \mathcal{T}$, jeżeli $H(\pi,t)=1$, $(a_i, t)\in N$ oraz $t+1\leq T_{\infty}$, wtedy $(a_i,t)\in E$.
		\item Dla każdego wyrażenia $(impossible \; a_i \; if\;  \pi )$ i dla każdego momentu czasu $t \in \mathcal{T}$, jeżeli $H(\pi,t)=1$, wtedy $(a_i,t) \notin E $.
		\item Dla każdego wyrażenia $(always \; \pi )$ i dla każdego momentu czasu $t \in \mathcal{T}$, $H(\pi,t)=1$.
   \end{itemize}
   \begin{definition}
   Niech $S = (H,O,E,T_{\infty})$ będzie strukturą języka $\mathcal{AL}$ , $ Sc=(OBS,ACS) $ będzie scenariuszem, oraz $ D $ dziedziną. Powiemy, że $ S $ jest strukturą dla $Sc$ zgodną z opisem domeny $D$, jeśli:
   		\begin{itemize} 
     		\item Dla każdej obserwacji $(\alpha,t )\in OBS$ mamy $H(\alpha,t )=1$
     		\item $ACS \subseteq E$ 
     		\item Dla każdej akcji $ {a_i \in \mathcal{A}}$ oraz dla każdego czasu rozpoczęcia akcji $t \in \mathcal{T}$, jeżeli $(a_i,t) \in E $, to $t+1 \leq T_{\infty}$. 
    		\end{itemize} 
   \end{definition}
   \begin{definition}
	   Niech $O_{1}$,$O_{2}$: $X \longrightarrow 2^{Y}$. Mówimy, że $O_{1} \prec O_{2}$ jeżeli $\forall x\in X$ $O_{1}(x)\subseteq O_{2}(x)$ oraz $O_{1}\neq O_{2}$.
   \end{definition}
   
   \begin{definition}
   Niech $S=(H,O,E,T_{\infty})$ będzie strukturą dla scenariusza $Sc=(OBS,ACS)$ zgodną z opisem dziedziny $D$. Mówimy, że $S$ jest $O$-minimalną strukturą, jeżeli nie istnieje struktura \\$S'=(H',O',E',T_{\infty}')$ dla tego samego scenariusza i domeny taka, że $O'\prec O$.  
   \end{definition}
   \begin{definition}
   Niech $S=(H,O,E,T_{\infty})$ będzie strukturą dla scenariusza $Sc=(OBS,ACS)$ zgodną z opisem domeny $D$. $S$ będziemy nazywać modelem $Sc$ zgodnym z opisem $D$ jeżeli:
   \begin{itemize}
		\item $S$ jest $O$-minimalny
		\item Dla każdego momentu w czasie $t \in \mathcal{T}$,  \{$f\in F$: $H(f,t)\neq H(f,t+1) $\} $\subseteq O(a_i,t+1)$ dla pewnej akcji $a_i$.
		\item Nie istnieje żadna struktura $S'=(H',O',E')$ dla $Sc$ zgodna z opisem $D$, która spełnia poprzednie warunki oraz taka, że $E'\subset E$. 
   \end{itemize}
\end{definition}

\begin{remark}
Nie dla każdego scenariusza można ułożyć model. Mówimy, że scenariusz $Sc$ jest \textit{zgodny} jeśli istnieje do niego model zgodny z dziedziną $D$.
\end{remark}

\section{Język zapytań}\label{sc:kwerendy}
Zdefiniowany język akcji może być odpytywany przez poniższy język zapytań,
który zwraca odpowiedzi \texttt{TRUE/FALSE} na następujące pytania
\begin{description}[style=nextline]
	\item[Czy w chwili $t$ realizacji scenariusza $Sc$ warunek $\gamma$ zachodzi zawsze/kiedykolwiek/na ogół?]
	$\texttt{always/ever/generally } \gamma \texttt{ at } t \texttt{ when } Sc$
	\item[Czy w chwili $t$ realizacji scenariusza $Sc$ akcja $a$ wykonywana jest zawsze/kiedykolwiek?]
	$\texttt{always/ever/generally performed } a_i \texttt{ at } t \texttt{ when } Sc$
	\item[Czy realizacji scenariusza $Sc$ zaangażowana jest grupa agentów $Ag$ zawsze/kiedykolwiek?]
	$\texttt{always/ever involved } Ag \texttt{ when } Sc$	
\end{description}

\subsection{Przykłady}
Rozważmy system opisany w przykładzie \ref{przyk:syntaktyka_jezyka_akcji}.
\begin{example}[Czy Cieć jest zawsze zaangażowany w realizację scenariusza]
	$$
	\texttt{always involved } \textsc{DoorKepper} \texttt{ when } Sc
	$$
	$\texttt{FALSE}$ -- Cieć zazwyczaj zamyka akademik ale nie zawsze.
\end{example}
\begin{example}[Czy w chwili 11 realizacji scenariusza $Sc$ Janek zawsze jest w akademiku]
	$$
	\texttt{always } inHostel \texttt{ at } 11 \texttt{ when } Sc
	$$
	$\texttt{FALSE}$ -- Janek zazwyczaj ma klucz który umożliwia wejście do akademika ale nie zawsze.
\end{example}


\subsection{Semantyka}
Niech $Sc$ będzie scenariuszem, a $D$ opisem domeny języka. Powiemy, że kwerenda $Q$ jest konsekwencją $Sc$ zgodnie z $D$ (ozn. $Sc,\ D\ |\approx\ Q $)

\begin{itemize}
	\item zapytanie kwerendą $Q$ postaci $\gamma\ at\ t\ when\ Sc$\\ zwróci wynik $TRUE$ jeśli dla każdego modelu $S=(H,O,E,N,T_{\infty})$ scenariusza $Sc$ zgodnego z $D$ zajdzie\\
	\begin{description}
		\item[always] $\forall_{t \in \mathcal{T}}\ H(\gamma,t)=1$ 
		\item[ever] $\exists_{t \in \mathcal{T}}\ H(\gamma,t)=1$
		\item[generally] $\forall_{(a_i,t)\in \mathcal{T}} H(\gamma,t)=1$
	\end{description}
	\item zapytanie kwerendą $Q$ postaci $performed\ a_i\ at\ t\ when\ Sc$\\ zwróci wynik $TRUE$ jeśli dla każdego modelu $S=(H,O,E,N,T_{\infty})$ scenariusza $Sc$ zgodnego z $D$ zajdzie
	\begin{description}
		\item[always] $\forall_{t \in \mathcal{T}} (a_i,t) \in E$
		\item[ever] $\exists_{t \in \mathcal{T}} (a_i,t) \in E$
		\item[generally] $\forall_{(a_i,t)\in \mathcal{T}} (a_i,t) \in E$
	\end{description}
	\item zapytanie kwerendą $Q$ postaci $involved\ Ag\ when\ Sc$\\ zwróci wynik $TRUE$ jeśli dla każdego modelu $S=(H,O,E,N,T_{\infty})$ scenariusza $Sc$ zgodnego z $D$ zajdzie ...
	\todo[inline] {nie wiem jak tu tego agenta włączyć.}
\end{itemize}

\begin{remark}
   Jeśli warunek nie zajdzie program zwróci wartość $FALSE$.
\end{remark}
\section{Przykłady}
\todo{Dodać kilka przykładów z scenariuszem (+ ilustracja), kwerendą i wyjaśnieniem dlaczego tak}
\begin{example}
	\begin{align*}
		&\texttt{initially} \neg hasMoney, \neg hasBread \\
	 	&\neg hasMoney &\texttt{triggers}, UseATM \\
		&UseATM &\texttt{typically triggers} BuyBread \\
		&BuyBread &\texttt{causes} hasBread, \neg hasMoney \\
		&hasBread &\texttt{typically invokes} EatBread \\
 		&EatBread &\texttt{causes} \neg hasBread \\
	\end{align*}
\end{example}

\end{document}
